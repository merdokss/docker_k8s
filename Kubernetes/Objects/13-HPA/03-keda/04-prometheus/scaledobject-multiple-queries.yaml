apiVersion: keda.sh/v1alpha1
kind: ScaledObject
metadata:
  name: prometheus-multi-scaledobject
  namespace: default
spec:
  scaleTargetRef:
    name: my-app-with-metrics
  minReplicaCount: 1
  maxReplicaCount: 20
  pollingInterval: 15
  cooldownPeriod: 300
  triggers:
  # Trigger 1: HTTP Requests per second
  - type: prometheus
    metadata:
      serverAddress: http://prometheus-kube-prometheus-prometheus.monitoring.svc:9090
      metricName: http_requests_total_rate
      query: |
        sum(rate(http_request_duration_seconds_count{app="my-app-with-metrics"}[1m]))
      threshold: "100"
      ignoreNullValues: "true"
  
  # Trigger 2: Active HTTP connections
  - type: prometheus
    metadata:
      serverAddress: http://prometheus-kube-prometheus-prometheus.monitoring.svc:9090
      metricName: http_requests_in_progress
      query: |
        sum(http_requests_in_progress{app="my-app-with-metrics"})
      threshold: "50"
      ignoreNullValues: "true"
  
  # Trigger 3: Memory usage percentage
  - type: prometheus
    metadata:
      serverAddress: http://prometheus-kube-prometheus-prometheus.monitoring.svc:9090
      metricName: memory_usage_percent
      query: |
        avg(
          container_memory_working_set_bytes{pod=~"my-app-with-metrics.*"} /
          container_spec_memory_limit_bytes{pod=~"my-app-with-metrics.*"}
        ) * 100
      threshold: "75"  # 75% memory usage
      ignoreNullValues: "true"
  
  # Trigger 4: P95 Response time
  - type: prometheus
    metadata:
      serverAddress: http://prometheus-kube-prometheus-prometheus.monitoring.svc:9090
      metricName: http_response_time_p95
      query: |
        histogram_quantile(
          0.95,
          sum(rate(http_request_duration_seconds_bucket{app="my-app-with-metrics"}[5m])) by (le)
        )
      threshold: "1.0"  # 1 second
      ignoreNullValues: "true"
  
  # UWAGA: Gdy wiele triggerów jest aktywnych,
  # KEDA używa największej wymaganej liczby replik

